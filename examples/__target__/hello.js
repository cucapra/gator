'use strict';var time={};import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,
    __ipow__,__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__proxy__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,
    filter,float,getattr,hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import*as __module_time__ from"./time.js";__nest__(time,"",__module_time__);var __name__="__main__";export var _default_no_edge=-1;export var BaseOnlineChecker=__class__("BaseOnlineChecker",[object],{__module__:__name__,_invalid_node:-1,
    _debug:false,get concatLists(){return __get__(this,function(self,list1,list2){var lst=[];for(var elem of list1)lst.append(elem);for(var elem of list2)lst.append(elem);return lst})},get getForwardEdges(){return __get__(this,function(self,source){return function(){var __accu0__=[];for(var i=0;i<len(self.graph);i++)if(self.graph[source][i]!=self._no_edge)__accu0__.append(i);return __accu0__}()})},get getBackwardEdges(){return __get__(this,function(self,sink){return function(){var __accu0__=[];for(var i=
    0;i<len(self.graph);i++)if(self.graph[i][sink]!=self._no_edge&&i!=sink)__accu0__.append(i);return __accu0__}()})},get getEmptyPathList(){return __get__(this,function(self){var paths=[];for(var _=0;_<len(self.graph);_++)paths.append([]);return paths})},get buildCompactFwdGraph(){return __get__(this,function(self){self.compactFwdGraph=self.getEmptyPathList();for(var node=0;node<len(self.graph);node++)self.compactFwdGraph[node]=self.getForwardEdges(node)})},get buildCompactBkdGraph(){return __get__(this,
    function(self){self.compactBkdGraph=self.getEmptyPathList();for(var node=0;node<len(self.graph);node++)self.compactBkdGraph[node]=self.getBackwardEdges(node)})},get getAllPredecessors(){return __get__(this,function(self,node,memoize){if(typeof memoize=="undefined"||memoize!=null&&memoize.hasOwnProperty("__kwargtrans__"))var memoize=false;if(!self.compactBkdGraph)self.buildCompactBkdGraph();var memoize=memoize||node==self.newEdgeSource;if(memoize)var pathDict=dict();var visited=set();var visitedList=
    [];var currentNode=node;var stack=[currentNode];var path=[];while(len(stack)>0){var currentNode=stack.py_pop();if(currentNode==self._invalid_node)var path=path.__getslice__(1,null,1);else if(!__in__(currentNode,visited)){visited.add(currentNode);visitedList.append(currentNode);var path=self.concatLists([currentNode],path);if(memoize)pathDict[currentNode]=self.deepcopyList(path);stack.append(self._invalid_node);var stack=self.concatLists(stack,self.compactBkdGraph[currentNode])}}if(self._debug)print("getAllPredecessors: node: {} and visitedList: {}".format(node,
    visitedList));if(node==self.newEdgeSource)self.pathsToNewEdgeSource=pathDict;if(memoize)self.pathsToNode[node]=pathDict;return visitedList})},get getAllPredecessorsUnordered(){return __get__(this,function(self,node,memoize){if(typeof memoize=="undefined"||memoize!=null&&memoize.hasOwnProperty("__kwargtrans__"))var memoize=true;var memoize=memoize||node==self.newEdgeSource;if(memoize)var pathDict=dict();var visited=set();var currentNode=node;var stack=[currentNode];var path=[];while(len(stack)>0){var currentNode=
    stack.py_pop();if(currentNode==self._invalid_node)var path=path.__getslice__(1,null,1);else if(!__in__(currentNode,visited)){visited.add(currentNode);var path=[currentNode]+path;if(memoize)pathDict[currentNode]=self.deepcopyList(path);stack.append(self._invalid_node);var stack=self.extend(stack,self.compactBkdGraph[currentNode])}}if(self._debug)print("getAllPredecessors: node: {} and visitedList: {}".format(node,visited));if(node==self.newEdgeSource)self.pathsToNewEdgeSource=pathDict;if(memoize)self.pathsToNode[node]=
    pathDict;return visited})},get getAllSuccessors(){return __get__(this,function(self,node){if(!self.compactFwdGraph)self.buildCompactFwdGraph();var visited=set();var visitedList=[];var currentNode=node;var stack=[node];var path=[];while(len(stack)>0){var currentNode=stack.py_pop();if(currentNode==self._invalid_node)path.py_pop();else if(!__in__(currentNode,visited)){visited.add(currentNode);visitedList.append(currentNode);path.append(currentNode);if(node==self.newEdgeSink)self.pathsFromNewEdgeSink[currentNode]=
    self.deepcopyList(path);stack.append(self._invalid_node);var stack=self.concatLists(stack,self.compactFwdGraph[currentNode])}}if(self._debug)print("getAllSuccessors: node = {} and visited list: {}".format(node,visitedList));return visitedList})},get deepcopyList(){return __get__(this,function(self,path){var copy=[];for(var entry of path)copy.append(entry);return copy})},get findPath(){return __get__(this,function(self,source,sink){var path=[];var visited=set();var stack=[source];while(len(stack)>
    0){var currentNode=stack.py_pop();if(currentNode==self._invalid_node)var path=path.__getslice__(0,-1,1);else if(!__in__(currentNode,visited)){path.append(currentNode);if(currentNode==sink)return tuple([true,path]);visited.add(currentNode);stack.append(self._invalid_node);var stack=self.concatLists(stack,self.compactFwdGraph[currentNode])}}return tuple([false,[]])})},get findPair(){return __get__(this,function(self,source,sink){if(!bool(self.pathsFromNewEdgeSink))self.getAllSuccessors(self.newEdgeSink);
    if(!bool(self.pathsToNewEdgeSource))self.getAllPredecessors(self.newEdgeSource);var firstSegment=self.pathsToNewEdgeSource[source];var lastSegment=self.pathsFromNewEdgeSink[sink];var __left0__=self.findPath(source,sink);var _=__left0__[0];var secondPath=__left0__[1];if(source==sink)var secondPath=self.identityFunction(source);var firstPath=self.concatLists(firstSegment,lastSegment);return tuple([firstPath,secondPath])})},get __init__(){return __get__(this,function(self){self.graph=[[]];self.identityFunction=
    function __lambda__(source){return[source]};self.newEdgeSource=self._invalid_node;self.newEdgeSink=self._invalid_node;self.timeTaken=0;self.compactFwdGraph=[];self.compactBkdGraph=[];self.pathsToNewEdgeSource=dict();self.pathsFromNewEdgeSink=dict();self.pathsToNode=dict();self._no_edge=_default_no_edge;self.noIdentity=false;self.pathsToNode=dict();self._invalid_node=-1})},get setGraph(){return __get__(this,function(self,graph,noEdge){if(typeof noEdge=="undefined"||noEdge!=null&&noEdge.hasOwnProperty("__kwargtrans__"))var noEdge=
    _default_no_edge;self.graph=graph;self._no_edge=noEdge;self.buildCompactBkdGraph();self.buildCompactFwdGraph()})},get setEdge(){return __get__(this,function(self,source,sink){self.newEdgeSource=source;self.newEdgeSink=sink})},get getPathsToCheck(){return __get__(this,function(self){})},get getComputeTime(){return __get__(this,function(self){return self.timeTaken})},get setIdFunction(){return __get__(this,function(self,idFunction){self.identityFunction=idFunction})}});export var OptimalSetPathChecker=
    __class__("OptimalSetPathChecker",[BaseOnlineChecker],{__module__:__name__,get __init__(){return __get__(this,function(self){__super__(OptimalSetPathChecker,"__init__")(self)})},get getSuccessors(){return __get__(this,function(self,source,sink){var predecessors=self.getAllPredecessors(source);var successors=self.getAllSuccessors(sink);if(self.noIdentity&&source==sink)return function(){var __accu0__=[];for(var src of predecessors)for(var snk of successors)if(src==snk)__accu0__.append(tuple([src,snk]));
    return set(__accu0__)}();return function(){var __accu0__=[];for(var src of predecessors)for(var snk of successors)__accu0__.append(tuple([src,snk]));return set(__accu0__)}()})},get getRootPairs(){return __get__(this,function(self){var acceptedPairs=set();var predecessors=self.getAllPredecessors(self.newEdgeSource);var successors=self.getAllSuccessors(self.newEdgeSink);var potentialPairs=function(){var __accu0__=[];for(var source of predecessors)for(var sink of successors)__accu0__.append(tuple([source,
    sink]));return set(__accu0__)}();while(len(potentialPairs)!=0){var __left0__=potentialPairs.py_pop(0);var source=__left0__[0];var sink=__left0__[1];var __left0__=self.findPath(source,sink);var pathExists=__left0__[0];var _=__left0__[1];if(pathExists){var currentPairSuccessors=self.getSuccessors(source,sink);for(var redundantPair of acceptedPairs.intersection(currentPairSuccessors))try{acceptedPairs.remove(redundantPair)}catch(__except0__){}for(var redundantPair of potentialPairs.intersection(currentPairSuccessors))try{potentialPairs.remove(redundantPair)}catch(__except0__){}acceptedPairs.add(tuple([source,
    sink]))}}return acceptedPairs})},get removePairFromList(){return __get__(this,function(self,lst,pair){var indices=[];for(var i=0;i<len(lst);i++){var elem=lst[i];if(pair[0]==elem[0]&&pair[1]==elem[1])indices.append(i)}for(var i of indices)var lst=self.concatLists(lst.__getslice__(0,i,1),lst.__getslice__(i+1,null,1));return lst})},get getPathsToCheck(){return __get__(this,function(self){var startTime=time.time();var subset=self.getRootPairs();var pathPairs=[];for(var node of subset){var __left0__=node;
    var source=__left0__[0];var sink=__left0__[1];pathPairs.append(self.findPair(source,sink))}var endTime=time.time();self.timeTaken=endTime-startTime;return pathPairs})}});export var PolynomialPathChecker=__class__("PolynomialPathChecker",[BaseOnlineChecker],{__module__:__name__,get __init__(){return __get__(this,function(self){__super__(PolynomialPathChecker,"__init__")(self)})},get getPathsToCheck(){return __get__(this,function(self){var startTime=time.time();var pathsToCheck=[];var predecessors=
    self.getAllPredecessors(self.newEdgeSource);var successors=self.getAllSuccessors(self.newEdgeSink);var predecessorSet=set(predecessors);for(var sink of successors){var predecessorsForNode=self.getAllPredecessors(sink,__kwargtrans__({memoize:true})).intersection(predecessorSet);while(len(predecessorsForNode)>0){var src=predecessorsForNode.py_pop();var part1=self.pathsToNewEdgeSource[src];var part2=self.pathsFromNewEdgeSink[sink];var newPath=self.concatLists(part1,part2);var oldPath=self.identityFunction(sink);
    if(src!=sink){var __left0__=self.findPath(src,sink);var _=__left0__[0];var oldPath=__left0__[1]}pathsToCheck.append(tuple([newPath,oldPath]))}}var endTime=time.time();self.timeTaken=endTime-startTime;return pathsToCheck})}});export var _EMPTY=0;export var optimalChecker=OptimalSetPathChecker();export var polyChecker=PolynomialPathChecker();export var defaultChecker=optimalChecker;export var polynomialCheckerFlag="Polynomial";export var optimalCheckerFlag="Optimal";export var suffixPolynomial="_poly";
    export var suffixOptimal="_opt";export var getChecker=function(flag){if(flag==polynomialCheckerFlag)return polyChecker;if(flag==optimalCheckerFlag)return optimalChecker;return defaultChecker};export var getElement=function(py_name,flag){if(flag==polynomialCheckerFlag)return py_name+suffixPolynomial;if(flag==optimalCheckerFlag)return py_name+suffixOptimal;return py_name};export var oracle=function __lambda__(matrix1,matrix2){return matrix1==matrix2};export var getPathListString=function(pathList){var string=
    "";for(var pair of pathList){var __left0__=pair;var path1=__left0__[0];var path2=__left0__[1];string+="("+path1+" and "+path2+") "}return string};export var getTime=function(checkerFlag){var checker=getChecker(checkerFlag);var elementName=getElement("time",checkerFlag);document.getElementById(elementName).innerHTML=checker.getComputeTime()+"s"};export var getPathsToCheck=function(checkerFlag){var checker=getChecker(checkerFlag);var elementName=getElement("paths",checkerFlag);if(len(checker.graph)!=
    _EMPTY&&len(checker.graph[0])!=_EMPTY&&checker.newEdgeSource!=checker._invalid_node&&checker.newEdgeSink!=checker._invalid_node){var paths=checker.getPathsToCheck();document.getElementById(elementName).innerHTML=getPathListString(paths)}else document.getElementById(elementName).innerHTML="Graph or new edge not yet set."};export var setGraph=function(checkerFlag){var checker=getChecker(checkerFlag);var elementName=getElement("graph",checkerFlag);var graphString=document.getElementById(elementName).value;
    var rows=graphString.py_split(";");var graph=[];for(var rowString of rows){var row=[];var splitRow=rowString.py_split();for(var edge of splitRow)row.append(int(edge));graph.append(row)}checker.setGraph(graph)};export var setNewEdge=function(checkerFlag){var checker=getChecker(checkerFlag);var elementName=getElement("edge",checkerFlag);var edgeString=document.getElementById(elementName).value;var __left0__=edgeString.py_split();var source=__left0__[0];var sink=__left0__[1];checker.setEdge(int(source),
    int(sink))};export var scalarMultiply=function(scalar,matrix){var ans=[];for(var row of matrix){var ansRow=[];for(var elem of row)ansRow.append(scalar*elem);ans.append(ansRow)}return ans};export var matrixMultiply=function(mat1,mat2){if(isinstance(mat1,list))if(isinstance(mat2,list)){var ans=[];for(var row=0;row<len(mat1);row++){var vector1=mat1[row];for(var col=0;col<len(mat2[0]);col++){var vector2=function(){var __accu0__=[];for(var i=0;i<len(mat2);i++)__accu0__.append(mat2[i][col]);return __accu0__}();
    var sumOfEntries=0;for(var i=0;i<len(vector2);i++)sumOfEntries+=vector1[i]*vector2[i];if(len(ans)<row+1)ans.append([]);ans[row].append(sumOfEntries)}}return ans}else return scalarMultiply(__kwargtrans__({scalar:mat2,matrix:mat1}));else if(isinstance(mat2,list))return scalarMultiply(__kwargtrans__({scalar:mat1,matrix:mat2}));else return mat1*mat2};export var getMatrixOfPaths=function(path,graphValues){if(len(path)<2)return 1;var productMatrix=graphValues[path[0]][path[1]];for(var i=2;i<len(path);i++){var edgeMatrix=
    graphValues[path[i-1]][path[i]];var productMatrix=matrixMultiply(productMatrix,edgeMatrix)}return productMatrix};export var checkPaths=function(pathsToCheck,graphValues,oracle){for(var pathPair of pathsToCheck){var __left0__=pathPair;var path1=__left0__[0];var path2=__left0__[1];var matrix1=getMatrixOfPaths(path1,graphValues);var matrix2=getMatrixOfPaths(path2,graphValues);if(!oracle(matrix1,matrix2))return false}return true};export var verify=function(graph,graphValues,newEdge,oracle){defaultChecker.setGraph(graph);
    defaultChecker.setEdge(newEdge[0],newEdge[1]);var pathsToCheck=defaultChecker.getPathsToCheck();return checkPaths(pathsToCheck,graphValues,oracle)};export var gatorTest=function(){var NO_EDGE=_default_no_edge;var graph1=[[-1,1,-1],[-1,-1,1],[-1,-1,-1]];var newEdge1=tuple([0,2]);var graphValue1=[[1,1,1],[1,1,1],[1,1,1]];var oracle1=function __lambda__(a,b){return a==b};var expectedOutcome1=true;var testGraphs=[graph1];var newEdge=[newEdge1];var oracles=[oracle1];var graphValues=[graphValue1];var expectedOutcomes=
    [expectedOutcome1];var testsSucceeded=true;for(var i=0;i<testGraphs;i++){var outcome=verify(testGraphs[i],graphValues[i],newEdge[i],oracles[i]);var testsSucceeded=testsSucceeded&&outcome==expectedOutcomes[i]}document.getElementById("gator").innerHTML="succeeded: "+testsSucceeded};
    
    //# sourceMappingURL=hello.map