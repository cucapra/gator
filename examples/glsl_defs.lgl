// GLSL Type Declarations
declare type vec2 is float[2];
declare type vec3 is float[3];
declare type vec4 is float[4];
declare type mat2 is float[2][2];
declare type mat3 is float[3][3];
declare type mat4 is float[4][4];
with float[4] T:
declare type sampler2D;
with float[4] T:
declare type samplerCube;

type scalar is float;
type angle is scalar;

// Numeric Operator Types
with float T: declare T +(T f1, T f2);
with float T: declare T -(T f1, T f2);
with float T: declare T *(T f1, T f2);
with float T: declare T /(T f1, T f2);
with float T: declare bool ==(T f1, T f2);
with float T: declare bool >=(T f1, T f2);
with float T: declare bool <=(T f1, T f2);
with float T: declare bool >(T f1, T f2);
with float T: declare bool <(T f1, T f2);

with int T: declare T +(T f1, T f2);
with int T: declare T -(T f1, T f2);
with int T: declare T *(T f1, T f2);
with int T: declare T /(T f1, T f2);
with int T: declare bool ==(T f1, T f2);
with int T: declare bool >=(T f1, T f2);
with int T: declare bool <=(T f1, T f2);
with int T: declare bool >(T f1, T f2);
with int T: declare bool <(T f1, T f2);

// GLSL Vector/Matrix Types
with vec3 T: declare T +(T v1, T v2);
with vec3 T: declare T -(T v1, T v2);
with vec3 T: declare T -(T v);
with vec3 T: with float U: declare T *(T v, U f);
with vec3 T: with float U: declare T *(U f, T v);
with vec3 T: with float U: declare T /(T f1, U f2);

with vec4 T: declare T +(T v1, T v2);
with vec4 T: declare T -(T v1, T v2);
with vec4 T: declare T -(T v);
with vec4 T: with float U: declare T *(T v, U f);
with vec4 T: with float U: declare T *(U f, T v);

with float T: declare T +(T f1, T f2);
with float T: declare T -(T f1, T f2);
with float T: declare T -(T f);
with float T: declare T *(T f1, T f2);
with float T: declare T /(T f1, T f2);

with mat3 T: with vec3 U: declare vec3 *(T m, U v);
with mat3 T: with mat3 U: declare mat3 +(T m, U v);
with mat3 T: with mat3 U: declare mat3 *(T m, U v);

with mat4 T: with vec4 U: declare vec4 *(T m, U v);
with mat4 T: with mat4 U: declare mat4 +(T m, U v);
with mat4 T: with mat4 U: declare mat4 *(T m, U v);


// GLSL function types
declare float cos(float f);
declare float sqrt(float f);
declare float acos(float f);

with float[4] T:
declare T texture2D(sampler2D<T> texture, float[2] coord);
with float[4] T:
declare T textureCube(samplerCube<T> texture, float[2] coord);

with float[3] T: with float U: declare vec4 vec4(T v, U f);
with float[4] T: declare vec3 vec3(T v);
with float[4][4] T: declare mat3 mat3(T v);
with float[3][3] T: declare mat4 mat4(T v);

with vec3 T: declare float dot(T v1, T v2);
// declare T normalize<T : vec3>(T x);
declare vec3 normalize(vec3 x);
with float T: declare T max(T f1, T f2);
with vec3 T: declare T reflect(T v1, T v2);
with float T: declare T pow(T f1, T f2);

// Geometric Objects and Operations

prototype geometry {
    object point;
    object vector;
    object direction;
    with frame() r: object transformation;

    vector +(vector x, vector y);
    vector -(vector x, vector y);
    vector -(vector x);
    direction -(direction x);
    vector *(vector v, scalar s);
    vector *(scalar s, vector v);
    point +(point p, vector v);
    point +(vector p, point v);
    vector -(point x, point y);
    vector -(point x);
    with frame() target:
    this<target>.vector *(transformation<target> m, vector v);

    with frame() target:
    this<target>.vector *(transformation<target> m, direction d);

    with frame() target:
    this<target>.point *(transformation<target> m, point p);

    with frame() target:
    transformation<target> +(transformation<target> m1, transformation<target> m2);

    with frame() middle, target:
    transformation<target> *(transformation<middle> m1, this<middle>.transformation<target> m2);

    angle dot(direction v1, direction v2);
    direction normalize(vector v);
    direction normalize(direction v);
    vector reflect(direction v1, direction v2);
}

// Coordinate Scheme Definitions

with frame(3) r:
coordinate cart3 : geometry {
    object point is float[3];
    object vector is float[3];
    object direction is float[3];
    with frame(3) r2: object transformation is float[3][3];

    vector +(vector x, vector y) {
        return (x as! vec3 + y as! vec3) as! vector;
    }
    vector -(vector x, vector y) {
        return (x as! vec3 - y as! vec3) as! vector;
    }
    vector *(vector v, scalar s) {
        return (v as! vec3 * s) as! vector;
    }
    vector *(scalar s, vector v) {
        return (s * v as! vec3) as! vector;
    }
    vector -(vector v) {
        return (-v as! vec3) as! vector;
    }
    direction -(direction v) {
        return (-v as! vec3) as! direction;
    }
    point +(point p, vector v) {
        return (p as! vec3 + v as! vec3) as! point;
    }
    point +(vector v, point p) {
        return (p as! vec3 + v as! vec3) as! point;
    }
    vector -(point x, point y) {
        return (x as! vec3 - y as! vec3) as! vector;
    }
    vector -(point v) {
        return (-v as! vec3) as! vector;
    }
    with frame(3) target:
    this<target>.vector *(transformation<target> m, vector v) {
        return (m as! mat3 * v as! vec3) as! this<target>.vector;
    }
    with frame(3) target:
    this<target>.vector *(transformation<target> m, direction d) {
        return (m as! mat3 * d as! vec3) as! this<target>.vector;
    }
    with frame(3) target:
    this<target>.point *(transformation<target> m, point p) {
        return (m as! mat3 * p as! vec3) as! this<target>.point;
    }
    with frame(3) target:
    transformation<target> +(transformation<target> m1, transformation<target> m2) {
        return (m1 as! mat3 + m2 as! mat3) as! transformation<target>;
    }
    with frame(3) middle, target:
    transformation<target> *(transformation<middle> m1, this<middle>.transformation<target> m2) {
        return (m1 as! mat3 * m2 as! mat3) as! transformation<target>;
    }

    angle dot(direction v1, direction v2) {
        return (dot(v1 as! vec3, v2 as! vec3) as! angle);
    }
    direction normalize(vector v) {
        return (normalize(v as! vec3) as! direction);
    }
    direction normalize(direction v) {
        return v;
    }
    vector reflect(direction v1, direction v2) {
        return (reflect(v1 as! vec3, v2 as! vec3) as! vector);
    }
}

with frame(3) r:
coordinate hom : geometry {
    object point is float[4];
    object vector is float[4];
    object direction is float[4];
    with frame(3) r2: object transformation is float[4][4];

    point +(point p, vector v) {
        return (p as! vec4 + v as! vec4 * p[3]) as! point;
    }
    point +(vector v, point p) {
        return (p as! vec4 + v as! vec4 * p[3]) as! point;
    }
    vector -(point x, point y) {
        return (x as! vec4 * y[3] - y as! vec4 * x[3]) as! vector;
    }
    with frame(3) target:
    this<target>.vector *(transformation<target> m, vector v) {
        return (m as! mat4 * v as! vec4) as! this<target>.vector;
    }
    with frame(3) target:
    this<target>.vector *(transformation<target> m, direction d) {
        return (m as! mat4 * d as! vec4) as! this<target>.vector;
    }
    with frame(3) target:
    this<target>.point *(transformation<target> m, point p) {
        return (m as! mat4 * p as! vec4) as! this<target>.point;
    }
    with frame(3) target:
    transformation<target> +(transformation<target> m1, transformation<target> m2) {
        return (m1 as! mat4 + m2 as! mat4) as! transformation<target>;
    }
    with frame(3) middle, target:
    transformation<target> *(transformation<middle> m1, this<middle>.transformation<target> m2) {
        return (m1 as! mat4 * m2 as! mat4) as! transformation<target>;
    }
}

// Transformation Functions
with frame(3) r:
canon hom<r>.point homify(cart3<r>.point v) {
    return vec4(v, 1.) as! hom<r>.point;
}
with frame(3) r:
canon hom<r>.vector homify(cart3<r>.vector v) {
    return vec4(v, 0.) as! hom<r>.vector;
}
with frame(3) r:
canon cart3<r>.point hom_reduce(hom<r>.point v) {
    return (vec3(v) / v[3]) as! cart3<r>.point;
}
with frame(3) r:
canon cart3<r>.vector hom_reduce(hom<r>.vector v) {
    return vec3(v) as! cart3<r>.vector;
}