declare float cos(float f);
declare float sqrt(float f);
declare float acos(float f);

prototype {
    object point<r>;
    object vector<r>;
    object direction<r>;
    object matrix<r1, r2>;

    vector<r> +(vector<r> x, vector<r> y);
    vector<r> -(vector<r> x, vector<r> y);
    vector<r> *(vector<r> v, scalar s);
    vector<r> *(scalar s, vector<r> v);
    vector<r> -(vector<r> v);
    position<r> translate(position<r> p, vector<r> v);
    position<r> +(position<r> p, vector<r> v);
    vector<r> -(position<r> x, position<r> y);
    vector<r2> *(matrix<r1, r2>, vector<r1>);
    vector<r2> *(matrix<r1, r2>, direction<r1>);
    point<r2> *(matrix<r1, r2>, point<r1>);
    matrix<r1, r2> +(matrix<r1, r2>, matrix<r1, r2>);
    matrix<r1, r3> *(matrix<r1, r2>, matrix<r2, r3>);
}

coord cart3 {
    dimension 3;

    point<r> = float[3];
    vector<r> = float[3];
    direction<r> = float[3];
    matrix<r1, r2> = float[3][3];

    vector<r> +(vector<r> x, vector<r> y) {
        return x + y;
    }
    vector<r> -(vector<r> x, vector<r> y) {
        return x - y;
    }
    vector<r> *(vector<r> v, scalar<r> s) {
        return v * s;
    }
    vector<r> *(scalar<r> s, vector<r> v) {
        return s * v;
    }
    vector<r> -(vector<r> v) {
        return -v;
    }
    position<r> translate(position<r> p, vector<r> v) {
        return p + v;
    }
    point<r> +(point<r> p, vector<r> v) {
        return p + v;
    }
    point<r> +(point<r> p, vector<r> v) {
        return p - v;
    }
    vector<r> -(point<r> x, point<r> y) {
        return x - y;
    }
    vector<r> -(point<r> v) {
        return -v;
    }

    vector<r2> *(matrix<r1, r2> m, vector<r1> v) {
        return m * v;
    }
    vector<r2> *(matrix<r1, r2> m, direction<r1> d) {
        return m * d;
    }
    point<r2> *(matrix<r1, r2> m, point<r1> p) {
        return m * p;
    }
    matrix<r1, r2> +(matrix<r1, r2> m1, matrix<r1, r2> m2) {
        return m1 + m2;
    }
    matrix<r1, r3> *(matrix<r1, r2> m1, matrix<r2, r3> m2) {
        return m1 * m2;
    }
}

coord hom {
    point<r> = float[4];
    vector<r> = float[4];
    direction<r> = float[4];
    matrix<r1, r2> = float[4][4];

    vector<r2> *(matrix<r1, r2> m, vector<r1> v) {
        return m * v;
    }
    vector<r2> *(matrix<r1, r2> m, direction<r1> d) {
        return m * d;
    }
    point<r2> *(matrix<r1, r2> m, point<r1> p) {
        return m * p;
    }
    matrix<r1, r2> +(matrix<r1, r2> m1, matrix<r1, r2> m2) {
        return m1 + m2;
    }
    matrix<r1, r3> *(matrix<r1, r2> m1, matrix<r2, r3> m2) {
        return m1 * m2;
    }
}

frame model is float[3];
frame world is float[3];

with frame(3) r,
declare cart3.direction<r> normalize(cart3.vector<r> v);
with frame(3) r,
declare float dot(cart3.direction<r> v1, cart3.direction<r> v2);
declare float[4] vec4(float[3] v, float f);

with frame(3) r,
hom.point<r> homify(cart3.point<r> v) {
    return vec4(v, 1.) as hom.point<r>;
}
with frame(3) r,
hom.vector<r> homify(cart3.vector<r> v) {
    return vec4(v, 1.) as hom.point<r>;
}
with frame(3) r,
cart3.point<r> reduce_hom(hom.point<r> v) {
    return vec3(v) / v[3] as cart3.point<r>;
}
with frame(2) r,
cart3.vector<r> reduce_hom(hom.vector<r> v) {
    return vec3(v) as cart3.vector<r>;
}

void main() {
    cart3.point<model> pos = [1., 2., 3.];
    cart3.point<world> light = [-1., -1., 0.];
    cart3.vector<world> offset = [2., 2., 2.];

    // Pure translation matrix
    hom.matrix<model, world> mtrans = 
        [[1., 0., 0., 1.], 
         [0., 1., 0., -1.],
         [0., 0., 1., 1.],
         [0., 0., 0., 1.]];

    hom.matrix<world, model> minv = 
        [[1., 0., 0., -1.], 
         [0., 1., 0., 1.],
         [0., 0., 1., -1.],
         [0., 0., 0., 1.]];

    print mtrans * mtrans; // Should bad frames for multiplication
}