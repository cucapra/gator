precision mediump float; vec3 hom_reduce_1(vec4 v){return vec3(v);}vec3 hom_reduce_0(vec4 v){return vec3(v)/v[3];}vec4 homify_1(vec3 v){return vec4(v, 0.);}vec4 homify_0(vec3 v){return vec4(v, 1.);}mat4 _gator_times_31(mat4 m2, mat4 m1){return m2*m1;}mat4 _gator_plus_18(mat4 m1, mat4 m2){return m1+m2;}vec4 _gator_times_30(mat4 m, vec4 p){return m*p;}vec4 _gator_times_29(mat4 m, vec4 d){return m*d;}vec4 _gator_times_28(mat4 m, vec4 v){return m*v;}vec4 _gator_minus_20(vec4 x, vec4 y){return x*y[3]-y*x[3];}vec4 _gator_plus_17(vec4 v, vec4 p){return p+v*p[3];}vec4 _gator_plus_16(vec4 p, vec4 v){return p+v*p[3];}vec3 reflect_5(vec3 v1, vec3 v2){return reflect(v1, v2);}vec3 reflect_4(vec3 v1, vec3 v2){return reflect(v1, v2);}vec3 normalize_5(vec3 v){return v;}vec3 normalize_4(vec3 v){return normalize(v);}float length_4(vec3 v){return length(v);}float dot_4(vec3 v1, vec3 v2){return dot(v1, v2);}mat3 _gator_times_27(mat3 m2, mat3 m1){return m2*m1;}mat3 _gator_plus_15(mat3 m1, mat3 m2){return m1+m2;}vec3 _gator_times_26(mat3 m, vec3 p){return m*p;}vec3 _gator_times_25(mat3 m, vec3 d){return m*d;}vec3 _gator_times_24(mat3 m, vec3 v){return m*v;}vec3 _gator_minus_19(vec3 v){return -v;}vec3 _gator_minus_18(vec3 x, vec3 y){return x-y;}vec3 _gator_plus_14(vec3 v, vec3 p){return p+v;}vec3 _gator_plus_13(vec3 p, vec3 v){return p+v;}vec3 _gator_minus_17(vec3 v){return -v;}vec3 _gator_minus_16(vec3 v){return -v;}vec3 _gator_times_23(float s, vec3 v){return s*v;}vec3 _gator_times_22(vec3 v, float s){return v*s;}vec3 _gator_minus_15(vec3 x, vec3 y){return x-y;}vec3 _gator_plus_12(vec3 x, vec3 y){return x+y;}vec2 reflect_3(vec2 v1, vec2 v2){return reflect(v1, v2);}vec2 reflect_2(vec2 v1, vec2 v2){return reflect(v1, v2);}vec2 normalize_3(vec2 v){return v;}vec2 normalize_2(vec2 v){return normalize(v);}float length_3(vec2 v){return length(v);}float dot_3(vec2 v1, vec2 v2){return dot(v1, v2);}mat2 _gator_times_21(mat2 m2, mat2 m1){return m2*m1;}mat2 _gator_plus_11(mat2 m1, mat2 m2){return m1+m2;}vec2 _gator_times_20(mat2 m, vec2 p){return m*p;}vec2 _gator_times_19(mat2 m, vec2 d){return m*d;}vec2 _gator_times_18(mat2 m, vec2 v){return m*v;}vec2 _gator_minus_14(vec2 v){return -v;}vec2 _gator_minus_13(vec2 x, vec2 y){return x-y;}vec2 _gator_plus_10(vec2 v, vec2 p){return p+v;}vec2 _gator_plus_9(vec2 p, vec2 v){return p+v;}vec2 _gator_minus_12(vec2 v){return -v;}vec2 _gator_minus_11(vec2 v){return -v;}vec2 _gator_times_17(float s, vec2 v){return s*v;}vec2 _gator_times_16(vec2 v, float s){return v*s;}vec2 _gator_minus_10(vec2 x, vec2 y){return x-y;}vec2 _gator_plus_8(vec2 x, vec2 y){return x+y;}uniform sampler2D uTexture;varying vec3 vPosition;varying vec3 vNormal;varying vec3 vShadowPos;uniform mat4 uModel;uniform mat4 uCamera;uniform vec3 uLight;uniform vec3 uBaseColor;uniform float uSpecStrength;vec4 app_uModel_0(vec4 v){return _gator_times_30(uModel, v);}vec4 app_uModel_1(vec4 v){return _gator_times_28(uModel, v);}vec4 app_uView_0(vec4 v){return _gator_times_30(uCamera, v);}vec4 app_uView_1(vec4 v){return _gator_times_28(uCamera, v);}vec4 extendColor_0(vec3 c){return vec4(c, 1.);}float decodeFloat_0(vec4 c){vec4 bitShift = vec4(1./16777216., 1./65536., 1./256., 1.);return dot(c, bitShift);}vec3 phong_light_0(vec3 lightPos, vec3 fragPos, vec3 normalDir, vec3 baseColor, float specStrength, float linear, float quad){float lambertian = max(0., dot_4(normalDir, normalize_4(_gator_minus_16(_gator_minus_19(lightPos)))));vec3 reflectDir = normalize_4(reflect_4(normalize_4(_gator_minus_19(lightPos)), normalDir));float specular = 0.;if (0.<=lambertian){ specular = pow(max(0., dot_4(normalize_4(_gator_minus_19(fragPos)), reflectDir)), 32.);}float distance = length_4(_gator_minus_18(lightPos, fragPos));float temp = linear*distance+quad*distance*distance;float attenuation = 1./temp;vec3 tempColor = lambertian*baseColor+specStrength*specular*vec3(1., 1., 1.);return tempColor*attenuation;}void main(){vec3 ambient = vec3(0.1, 0., 0.);float texelSize = 1./1024.;vec2 temp = vec2(vShadowPos[0], vShadowPos[1]);vec4 v = texture2D(uTexture, temp);float amountInLight = 0.;for (float x = -1.;x<=1.; x += 1.) { for (float y = -1.;y<=1.; y += 1.) { float texelDepth = decodeFloat_0(texture2D(uTexture, temp+vec2(x, y)*texelSize));if (vShadowPos[2]-0.007<=texelDepth){ amountInLight += 1.;}}}amountInLight /= 9.;vec3 phong_color = phong_light_0(uLight, hom_reduce_0(app_uModel_0(homify_0(vPosition))), normalize_4(hom_reduce_1(app_uModel_1(homify_1(vNormal)))), uBaseColor, uSpecStrength, 0.08, 0.0001);gl_FragColor = extendColor_0(ambient+phong_color*amountInLight);}