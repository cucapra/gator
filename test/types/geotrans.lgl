type vec3 is float[3];
type vec4 is float[4];
type mat3 is float[3][3];
type mat4 is float[4][4];
type scalar is float;

declare T +<T:vec3>(T v1, T v2);
declare T -<T:vec3>(T v1, T v2);
declare T -<T:vec3>(T v);
declare T *<T:vec3,U:float>(T v, U f);
declare T *<T:vec3,U:float>(U f, T v);
declare T /<T:vec3,U:float>(T f1, U f2);

declare T +<T:vec4>(T v1, T v2);
declare T -<T:vec4>(T v1, T v2);
declare T -<T:vec4>(T v);
declare T *<T:vec4,U:float>(T v, U f);
declare T *<T:vec4,U:float>(U f, T v);

declare T +<T:float>(T f1, T f2);
declare T -<T:float>(T f1, T f2);
declare T -<T:float>(T f);
declare T *<T:float>(T f1, T f2);
declare T /<T:float>(T f1, T f2);

declare vec3 *<T:mat3,U:vec3>(T m, U v);
declare mat3 +<T:mat3,U:mat3>(T m, U v);
declare mat3 *<T:mat3,U:mat3>(T m, U v);

declare vec4 *<T:mat4,U:vec4>(T m, U v);
declare mat4 +<T:mat4,U:mat4>(T m, U v);
declare mat4 *<T:mat4,U:mat4>(T m, U v);

declare float cos(float f);
declare float sqrt(float f);
declare float acos(float f);

declare vec4 vec4<t:float[3],u:float>(t v, u f);
declare vec3 vec3<t:float[4]>(t v);

prototype geometry {
    object point<r>;
    object vector<r>;
    object direction<r>;
    object matrix<r1, r2>;

    vector<r> +(vector<r> x, vector<r> y);
    vector<r> -(vector<r> x, vector<r> y);
    vector<r> -(vector<r> x);
    vector<r> *(vector<r> v, scalar s);
    vector<r> *(scalar s, vector<r> v);
    point<r> translate(point<r> p, vector<r> v);
    point<r> +(point<r> p, vector<r> v);
    point<r> +(vector<r> p, point<r> v);
    vector<r> -(point<r> x, point<r> y);
    vector<r> -(point<r> x);
    vector<r2> *(matrix<r1, r2> m, vector<r1> v);
    vector<r2> *(matrix<r1, r2> m, direction<r1> v);
    point<r2> *(matrix<r1, r2> m, point<r1> v);
    matrix<r1, r2> +(matrix<r1, r2> m1, matrix<r1, r2> m2);
    matrix<r1, r3> *(matrix<r1, r2> m1, matrix<r2, r3> m2);
}

coordinate cart3 : geometry {
    dimension 3;

    object point<r> is float[3];
    object vector<r> is float[3];
    object direction<r> is float[3];
    object matrix<r1, r2> is float[3][3];

    vector<r> +(vector<r> x, vector<r> y) {
        return (x as! vec3 + y as! vec3) as! vector<r>;
    }
    vector<r> -(vector<r> x, vector<r> y) {
        return (x as! vec3 - y as! vec3) as! vector<r>;
    }
    vector<r> *(vector<r> v, scalar s) {
        return (v as! vec3 * s) as! vector<r>;
    }
    vector<r> *(scalar s, vector<r> v) {
        return (s * v as! vec3) as! vector<r>;
    }
    vector<r> -(vector<r> v) {
        return (-v as! vec3) as! vector<r>;
    }
    point<r> translate(point<r> p, vector<r> v) {
        return (p as! vec3 + v as! vec3) as! point<r>;
    }
    point<r> +(point<r> p, vector<r> v) {
        return (p as! vec3 + v as! vec3) as! point<r>;
    }
    point<r> +(vector<r> v, point<r> p) {
        return (p as! vec3 + v as! vec3) as! point<r>;
    }
    vector<r> -(point<r> x, point<r> y) {
        return (x as! vec3 - y as! vec3) as! vector<r>;
    }
    vector<r> -(point<r> v) {
        return (-v as! vec3) as! vector<r>;
    }
    vector<r2> *(matrix<r1, r2> m, vector<r1> v) {
        return (m as! mat3 * v as! vec3) as! vector<r2>;
    }
    vector<r2> *(matrix<r1, r2> m, direction<r1> d) {
        return (m as! mat3 * d as! vec3) as! vector<r2>;
    }
    point<r2> *(matrix<r1, r2> m, point<r1> p) {
        return (m as! mat3 * p as! vec3) as! point<r2>;
    }
    matrix<r1, r2> +(matrix<r1, r2> m1, matrix<r1, r2> m2) {
        return (m1 as! mat3 + m2 as! mat3) as! matrix<r1, r2>;
    }
    matrix<r1, r3> *(matrix<r1, r2> m1, matrix<r2, r3> m2) {
        return (m1 as! mat3 * m2 as! mat3) as! matrix<r1, r3>;
    }
}

coordinate hom : geometry {
    dimension 3;

    object point<r> is float[4];
    object vector<r> is float[4];
    object direction<r> is float[4];
    object matrix<r1, r2> is float[4][4];

    point<r> +(point<r> p, vector<r> v) {
        return (p as! vec4 + v as! vec4 * p[3]) as! point<r>;
    }
    point<r> +(vector<r> v, point<r> p) {
        return (p as! vec4 + v as! vec4 * p[3]) as! point<r>;
    }
    vector<r> -(point<r> x, point<r> y) {
        return (x as! vec4 * y[3] - y as! vec4 * x[3]) as! vector<r>;
    }
    vector<r2> *(matrix<r1, r2> m, vector<r1> v) {
        return (m as! mat4 * v as! vec4) as! vector<r2>;
    }
    vector<r2> *(matrix<r1, r2> m, direction<r1> d) {
        return (m as! mat4 * d as! vec4) as! vector<r2>;
    }
    point<r2> *(matrix<r1, r2> m, point<r1> p) {
        return (m as! mat4 * p as! vec4) as! point<r2>;
    }
    matrix<r1, r2> +(matrix<r1, r2> m1, matrix<r1, r2> m2) {
        return (m1 as! mat4 + m2 as! mat4) as! matrix<r1, r2>;
    }
    matrix<r1, r3> *(matrix<r1, r2> m1, matrix<r2, r3> m2) {
        return (m1 as! mat4 * m2 as! mat4) as! matrix<r1, r3>;
    }
}

frame model has dimension 3;
frame world has dimension 3;

// declare with dimension(3) r,
// cart3.direction<r> normalize(cart3.vector<r> v);
// declare with dimension(3) r,
// float dot(cart3.direction<r> v1, cart3.direction<r> v2);
// declare float[4] vec4(float[3] v, float f);

with frame(3) r:
hom.point<r> homify(cart3.point<r> v) {
    return vec4(v, 1.) as! hom.point<r>;
}
with frame(3) r:
hom.vector<r> homify(cart3.vector<r> v) {
    return vec4(v, 1.) as! hom.point<r>;
}
with frame(3) r:
cart3.point<r> reduce_hom(hom.point<r> v) {
    return (vec3(v) / v[3]) as! cart3.point<r>;
}
with frame(3) r:
cart3.vector<r> reduce_hom(hom.vector<r> v) {
    return vec3(v) as! cart3.vector<r>;
}

void main() {
    cart3.point<model> pos = [1., 2., 3.];
    cart3.point<world> light = [-1., -1., 0.];
    cart3.vector<world> offset = [2., 2., 2.];

    // Pure translation matrix
    hom.matrix<model, world> mtrans = 
        [[1., 0., 0., 1.], 
         [0., 1., 0., -1.],
         [0., 0., 1., 1.],
         [0., 0., 0., 1.]];

    hom.matrix<world, model> minv = 
        [[1., 0., 0., -1.], 
         [0., 1., 0., 1.],
         [0., 0., 1., -1.],
         [0., 0., 0., 1.]];

    hom.matrix<model, model> mid = mtrans * minv;

    hom.point<model> hpos = homify<model>(pos);
    hom.vector<world> hoff = homify<world>(offset);

    print hpos;
    print hoff;

    print (mtrans * hpos) + hoff;
    print mtrans * (hpos + (minv * hoff));  // Should be the same!
    print reduce_hom<world>(hpos - homify<world>(light) + homify<world>(offset));
}